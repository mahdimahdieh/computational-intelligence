% Exercise Template
%A LaTeX template for typesetting exercise in Persian (with cover page).
%By: Zeinab Seifoori

\documentclass[12pt]{exam}

\usepackage{setspace}
\usepackage{listings}
\usepackage{xcolor}

% Define colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


% Configure listings style
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize\setLTR,
	breakatwhitespace=true,         
	breaklines=true,                 
	captionpos=top, % Changed to top placement
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	frame=single,
	abovecaptionskip=5pt, % Space between caption and code
	belowcaptionskip=5pt, % Space between code and potential bottom text
}


\lstset{style=mystyle}

% Set Persian caption for listings
\renewcommand{\lstlistingname}{برنامه}

\usepackage{graphicx,subfigure,wrapfig}
\usepackage{float} %for floating shapes

\usepackage{multirow}
%\usepackage{multicol}


%%%%%%%%%  for pie chart %%%%%
\usepackage{pgf-pie}  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[margin=20mm]{geometry}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
	pdftitle={Overleaf Example},
	pdfpagemode=FullScreen,
}
\usepackage{xepersian}
\settextfont{XB Niloofar}

\newcommand{\class}{درس مبانی هوش محاسباتی}
\newcommand{\term}{نیم‌سال دوم ۰۱-۰۲}
\newcommand{\college}{دانشکده مهندسی کامپیوتر}
\newcommand{\prof}{استاد: دکتر کارشناس}

\onehalfspacing
\parindent 0ex
\begin{document}
	
	\include{info}
	\pagestyle{empty}
	\include{cover-page}
	
	% These commands set up the running header on the top of the exam pages
	\pagestyle{head}
	\firstpageheader{}{}{}
	\runningheader{صفحه \thepage\ از \numpages}{}{\class}
	\runningheadrule
	%\begin{tabular}{p{.7\textwidth} l}
	%\multicolumn{2}{c}{\textbf{به نام خدا}}\\
	%\multirow{2}{*}{\includegraphics[scale=0.2] {images/logo.png}} & \\ \\
	%&  \textbf{\class}\\
	%&  \textbf{\term}\\
	%&  \textbf{\prof}\\ \\
	% \textbf{\college} &  \\
	%\end{tabular}\\
	
	%\rule[1ex]{\textwidth}{.1pt}
	%\textbf{تمرین سری پنجم}
	
	%\rule[1ex]{\textwidth}{.1pt}
	%\makebox[45mm]{\hrulefill}\\
	\tableofcontents
	\vspace{1cm}
	\setcounter{section}{-1}
	\section{مقدمه}
	هدف از این تمرین آشنایی بیشتر با الگوریتم‌های ژنتیک و استفاده‌ی بیشتر از آن‌ها در کاربردهای عملی است.
	
	\newpage
	\section{
		مبانی و مفاهیم الگوریتم ژنتیک}
	
	\newpage
	\section{
		درک و حل مسائل با الگوریتم ژنتیک}
	\begin{questions}
		\question
		\begin{parts}
			\part
			 اگر هیچ گره‌ای نباید دو بار دیده شود، یک کروموزوم باید باید یک دور بین همه‌ی گره‌ها باشد که این دور شامل طی ترتیب طی کردن ۱۰ گره یا معادل طی کردن ۱۰ یال است. پس کروموزوم ما شامل ۱۰ ژن است.
			\part
			 اینکه بین کدام شهرها ارتباط وجود داشته باشد پیش‌فرض‌های مسئله است اما به طور کلی می‌توان گفت اگر گراف کامل و بدون طوقه باشد، از هر گره‌ای به همه‌ی گره‌های دیگر یال وجود دارد. ما در نظر گرفتیم این یال‌ها جهت‌دار است پس اگر از یک گره به گره‌ی دیگر رفت برگشت نیازی نیست. با این اوصاف تعداد کل ژن‌های ممکن 
			 $n\times \frac{n-1}{2}$
			 یال می‌شود. که اینجا 
			 $n=10$
			  است پس 
			  $10\times \frac{9}{2}=45$
			  ژن وجود دارد.
		\end{parts}
		
		\question
		\begin{parts}
			\part ژن‌ها  را به تابع 
			fitness
			می‌بریم:
			\[\mathrm{fit} (x_1) = 6+5-4-1+3+5-3-2=9 \]
			\[\mathrm{fit} (x_2) = 8+7-1-2+6+6-0-1=23\]
			\[\mathrm{fit} (x_3) = 2+3-9-2+1+2-8-5=-16\]
			\[\mathrm{fit} (x_4) = 4+1-8-5+2+0-9-4=-19 \]

			به ترتیب
			$x_2$، $x_1$،$x_3$ و $x_4$
			برازنده هستند.
			
			\part عملیات ترکیب
			\begin{itemize}
				\item
				ترکیب نقطه‌ای: در این روش به دو فرزند جدید می‌رسیم.
				\[x_{21} = 8712|3532\]
				\[x_{21}=6541|6601\]
				\item
				ترکیب دو نقطه‌ای: با استفاده از این روش به دو فرزند جدید می‌رسیم. ما فرض می‌کنیم منظور از نقاط b و f یعنی بعد از این نقاط ترکیب اتفاق می‌افتد
				\[x_{131} = 65|9212|35\]
				\[x_{313}=23|4135|85\]
				\item 
				ترکیب یکنواخت: برای انجام این ترکیب نیازمند به یک ماسک هستیم. این ماسک یک ژن تصادفی با مقادیر دودویی است که نشانگر این است که آن ژن را از کروموزوم اول بگیریم یا دوم. که انتخاب اول یا دوم هم احتمال است. ما با استفاده از
				
				
				\lstinputlisting[language=Python, caption= تولید ماسک تصادفی]{./scripts/mask.py}
				
				
				
				یک رشته‌ی تصادفی از ۰ و ۱ تولید می‌کنیم. ما فرض می‌کنیم ۰  معادل رشته‌ی اول و ۱ معادل رشته‌ی سوم باشد.
				
				\[\mathrm{mask} = 01001010\]
				\[x_{13} = 8|3|12|1|6|8|1\]
				\[x_{31}=2|7|92|6|2|0|5\]
			\end{itemize}
			\part
			برازش فرزندان: با استفاده از تکه کد زیر برازندگی هر فرزند را محاسبه می‌کنیم:
			
			
			\lstinputlisting[language=Python, caption= محاسبه‌ی برازندگی]{./scripts/fitness.py}
			
			\[\mathrm{fit} (x_{21} )= 87123532=15\]
			\[\mathrm{fit} (x_{21})= 65416601=17\]
			\[\mathrm{fit} (x_{131}) = 65921235 = -5\]
			\[\mathrm{fit} (x_{313}) = 23413585 = -5\]
			\[\mathrm{fit} (x_{23}) = 83121681 = 6\]
			\[\mathrm{fit} (x_{32}) = 27926205 =1\]
			تعبیر بهتر شدن و بدتر شدن تعبیر نا دقیقی است. ما دو شاخص را برای بهتر شدن و بدتر شدن در نظر می‌گیریم.
			\begin{enumerate}
				\item بالاترین برازندگی: در والدها بالاترین برازندگی ۲۳ بود که به ۱۷ کاهش یافت یعنی بدتر شده.
				\item میانگین برازندگی: در شرایط قبلی برازندگی معادل
				$\frac{9+23-16-19}{4}=\frac{-3}{4} =-0.75 $
				می‌شود و در فرزندان 
				$\frac{15+17-5-5+6+1}{6}=\frac{29}{6} \approx4.83 $
				می‌شود که رشد قابل توجهی است.
			\end{enumerate}
			\part
			برای بیشینه کردن برازندگی، ژن‌های
			\lr{a}، 
			\lr{b}،
			\lr{e} و
			\lr{f}
			باید مقدار ۹ داشته باشند و 
			\lr{c}، 
			\lr{d}،
			\lr{g} و
			\lr{h}
			باید مقدار ۰ را داشته باشند. برازندگی بهینه برابر 
			$4 \times 9 - 0 = 36$
			می‌شود.
			\part
			ما سعی کردیم بهترین ترکیب را بسیازیم  و آن
			$x_{\mathrm{optimal}}= 87116601$
			خواهد بود که برازندگی آن ۲۴ خواهد شد. پس نمی‌توان بدون جهش به نقطه‌ی بهینه رسید و حداقل ۱۲ تا فاصله با نقطه‌ی برازندگی وجود خواهد داشت.
		\end{parts} 
		\question
		\begin{parts}
			\part\label{p2-3-a}
			مقدار برازندگی به ازای هر 
			\lr{x}:
			\[\mathrm{fit} (x_{1}) = 1-4+7=4\]
			\[\mathrm{fit} (x_{2}) = 8-16+7=-1\]
			\[\mathrm{fit} (x_{3}) = 27-36+7=-2\]
			\[\mathrm{fit} (x_{4}) = 64-64+7=7\]
			\part
			بله. می‌توانیم با اضافه کردن 
			$\forall c : c \ge 2$
			همه‌ی مقدارها را نامنفی کنیم.
			مثلا اگر 
			$c=3$ 
			در نظر بگیریم رابطه‌ی برازندگی 
			$\mathrm{fit} (x) = x^3 - 4 x^2 + 10$
			خواهد شد.
			
			\part به هر برازندگی مقدار ثابت ۲ اضافه می‌شود پس 
			\[\mathrm{Total Fitness} = (4+3)\times 2+(-1+3)\times 3+(-2+3)\times3+(7+3)\times2\]
			\[=14+6+3+20=43\]
			\part 
			مقدار برازندگی نسبی برای هر نمونه‌ی  x به صورت زیر خواهد شد:
			
			\[ P(x=1) = \frac{7}{43} = 0.1628 \]  
			\[P(x=2)=\frac{2}{43}=0.0465\]
			\[P(x=3)=\frac{1}{43}=0.0233\]
			\[P(x=4)=\frac{10}{43}=0.2326\]
			می‌توانیم آن را به صورت یک گردونه هم نشان دهیم
			\begin{figure}[H]
				\begin{center}
\begin{tikzpicture}[x=0.05\textwidth, y=0.05\textwidth]
\pie{
	16/\rl{نفر اول}  ,
	16/دوم,
	5/سوم,
	5/چهارم,
	5/ پنجم,
	3/ششم,
	2/ هفتم,
	2/هشتم,
	23/نهم,
	23/ دهم}
	\end{tikzpicture}
	\caption{گردونه‌ی شانس برای این نمونه از جمعیت}
	\end{center}
\end{figure}
			

			
			\part 
			مزیت تابع جدید این است که به ازا‌ی هر مقدار 
			\lr{x}،
			تابع برازندگی همواره نامنفی است. برای محاسبه‌ی 
			$g(x)$
			تمام مقدادیر بدست آمده در بخش
			\ref{p2-3-a}
			را به توان ۲ می‌رسانیم.
			\[\mathrm{fit} (x_{1}) =4^2=16\]
			\[\mathrm{fit} (x_{2}) =(-1)^2=1\]
			\[\mathrm{fit} (x_{3}) =(-2)^2=4\]
			\[\mathrm{fit} (x_{4}) =7^2=49\]
			\part
			\begin{itemize}
				\item 
				\textbf{
				فشار انتخاب}:
				فشار انتخاب یعنی درجه‌ی اینکه افراد برازنده‌تر چقدر شانس زنده ماندن دارند.  برعکس اضافه کردن مقدار ثابت، در «به توان رساندن» فشار انتخاب زیاد می‌شود. البته این تا حدودی بستگی به روش انتخاب هم دارد. مثلا اگر از الگوریتم انتخاب رتبه پایه
				\footnote{\lr{rank-based selection}}
				استفاده کنیم دیگر این مسئله جدی نیست.
				
				\item 
				\textbf{
				همگرایی}:
				می‌توان گفت با افزایش فشار انتخاب، همگرایی سریع‌تر می‌شود اما خطر گیر کردن در یک نقطه‌ی بهینه‌ی محلی وجود دارد.
				
				\item 
				\textbf{
				تنوع:}
				افزایش فشار انتخاب باعث کاهش تنوع و همگرایی سریع به یک قله‌ی محلی خاص می‌شود که ممکن است بهترین نباشد. با افزایش فشار انتخاب تنوع در انتخاب گونه‌ها را از دست می‌دهیم.
			\end{itemize}
			
		\end{parts}
		
	\end{questions}
	
	\newpage
	\section[
	پیاده‌سازی، ارزیابی و تجزیه‌ و تحلیل الگوریتم ژنتیک]{پیاده‌سازی، ارزیابی و تجزیه‌ و تحلیل الگوریتم ژنتیک جهت انتخاب بهترین ویژگی برای مسئله‌ی واقعی دسته‌بندی مشتریان} 
	\begin{questions}
		\question
	 پیش پردازش داده‌ها:
		\begin{parts}
			\part
			حذف دادههای پرت:
					
			برای پر کردن دادههای پرت از روش 
		\lr{IQR method}
			استفاده میکنیم این روش به این صورت است که 
			\lr{IQR}
			را برابر با 
			\lr{Q3 - Q1}
			قرار میدهیم(چارک اول : 
			\lr{Q1},
			چارک سوم:
			\lr{Q3}
			)
			 سپس دادههای کوچکتر از 
			\lr{Q1 - 1.5*IQR}
			و بزرگتر از 
			\lr{Q3 + 1.5IQR}
			را حذف میکنیم.
			\lstinputlisting[language=Python, caption= حذف دادههای پرت]{./scripts/IQR.py}		
			\part
			رمزگذاری ویژگیهای دسته ای
			\lr{(categorical)}:
			
			مهم ترین پارامتر در رمزگذاری
			\lr{(encoding)}
			 داده های دسته ای این است که ببینیم که این داده ها داده های کیفی ترتیبی 
			 \lr{(Ordinal Qualitative)}
			 هستند یا کیفی اسمی
			 \lr{(Nominal Qualitative)}
			 اگر داده ها کیفی ترتیبی باشند نیاز داریم که داده ها را به گونه ای پیش پردازش بکنیم که این ترتیب همچنان حفظ شود و در صورتی که داده ها اسمی باشند نیازی به این کار نداریم و میتوانیم برای هر دسته یک ستون درست کنیم که با مقادیر درست 
			 \lr{(True)}
	و غلط
	  \lr{(False)}
	  مشخص کنیم که به این دسته قرار دارد یا خیر.
	  
	  در داده هایی که در سوال به ما داده شده بود ستون های 
	  \lr{Gender}، 
	  \lr{Ever\_Married}
	  ، 
	  \lr{Graduated}
	  ، 
	  \lr{Profession}
	  و 
	  \lr{Var\_1}
	  ستونهایی بودند که داده های انها به صورت کیفی اسمی بود و برای همین برای رمز گذاری انها از 
	  \lr{get\_dummies}
	   استفاده کردیم.

	   
	   \lstinputlisting[language=Python, caption=رمزگذاری با  
	   \lr{get\_dummies} ]{./scripts/get_dummies.py}
	   
	   
	   و ستون 
	   \lr{Spending\_Score}
	    را که دارای داده های ترتیبی به نام های 
	   \lr{Low}،
	    \lr{Average} و 
	     \lr{High}
	     بود را به صورت دیگری رمزگذاری کردیم تا مدل توانایی درک این که این 3 مقدار دارای ترتیب مشخصی هستند را متوجه شود.
	     
	     اینکار را به این صورت انجام دادیم که این 3 ستون را به ترتیب از کوچک به بزرگ از 0 تا 2 مقداردهی کردیم.
	     
	     \lstinputlisting[language=Python, caption=رمزگذاری برای ستون 
	     \lr{spending\_score}]{./scripts/spending_score.py}
	     
	\part
	پر کردن داده های خالی 
	\lr{(Nan)}
	:
	
	برای پرکردن داده های خالی از 
	\lr{KNNImputer}
	در کتابخانه sikitlearn استفاده کردیم به این صورت که 
	\lr{n\_neighbors} که یکی از پارامترهای این تابع است را 8 انتخاب کردیم و این به این معناست که هر ردیفی که مفدار خالی داشته باشد میاید و 8 ردیف نزدیک به ان را پیدا میکند و سپس از مقادیر ستون مورد نظر(یعنی ستونی که مقدار خالی در ان قرار دارد.)
	در ان ردیفها میانگین گرفته و انرا به عنوان مقدار جدید سلول خالی قرار میدهد.
	\lstinputlisting[language=Python, caption= پر کردن سلول‌های خالی]{./scripts/filling_nans.py}
	
	\end{parts}
	\end{questions}
	
	\begin{questions}
	\question

	پیاده سازی الگوریتم ژنتیک:
	
	الگوریتم ژنتیک یک روش جستجو و بهینه‌سازی مبتنی بر تکامل طبیعی است که در آن مفاهیمی از ژنتیک مانند انتخاب طبیعی، ترکیب و جهش برای یافتن بهترین جواب به کار گرفته می‌شوند. این الگوریتم در مسائل مختلف از جمله بهینه‌سازی، یادگیری ماشین و مسائل ترکیبیاتی مورد استفاده قرار می‌گیرد.
	
	مراحل الگوریتم ژنتیک:
	\begin{parts}
	\part
	مقداردهی اولیه 
	\lr{(Initialization)}
	:
	
	
	مجموعه‌ای از کروموزوم‌ها (یا راه‌حل‌های ممکن) به‌صورت تصادفی ایجاد می‌شود.
	\end{parts}
	\end{questions}
	
\end{document}